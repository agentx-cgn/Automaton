// This file is automatically generated!
// Toy Name:           Sphero RVR
// Prefix:             RV
// Command Count:      65
// Timestamp:          10/12/2019 @ 01:53:07.267881 (UTC)
import {ByteConversionUtilities} from '../utilities/byte-conversion-utilities';
import {LedControl} from './controls/led-control';
import {DriveControl} from './controls/drive-control';
import {InfraredControl} from './controls/infrared-control';
import {SensorControl} from './controls/sensor-control';
import {IAsyncDataHandler, IToy} from './toy-interface';

export class SpheroRvrToy implements IToy {
    private readonly _baseUrl: string;
    public get baseUrl(): string {
        return this._baseUrl;
    }
    private readonly _asyncHandlerByName: Map<string, IAsyncDataHandler>;
    public get asyncHandlerByName(): Map<string, IAsyncDataHandler> {
        return this._asyncHandlerByName;
    }
    private readonly _ledControl: LedControl;
    private readonly _driveControl: DriveControl;
    private readonly _infraredControl: InfraredControl;
    private readonly _sensorControl: SensorControl;
    public static readonly primaryTarget: number = 1;
    public static readonly secondaryTarget: number = 2;

    constructor(ipAddress: string, port: number) {
        this._baseUrl = 'http://' + ipAddress + ':' + port + '/api' + '/v1.0';

        this._asyncHandlerByName = new Map<string, IAsyncDataHandler>();

        const socket = new WebSocket('ws://' + ipAddress + ':' + port + '/stream');
        socket.onopen = () => {
            socket.send('Hello from client!');
        };
        socket.onmessage = (e) =>  {
            let asyncCommand: IAsyncCommandObject = JSON.parse(e.data);
            let key: string = this.getAsyncMapKey(asyncCommand._sourceId, asyncCommand._deviceId, asyncCommand._commandId);
            let handler: IAsyncDataHandler | undefined = this.asyncHandlerByName.get(key);
            if (handler == undefined) {
                return;
            }
            handler(asyncCommand._data);
        };

        this._ledControl = new LedControl(this);
        this._driveControl = new DriveControl(this);
        this._infraredControl = new InfraredControl(this);
        this._sensorControl = new SensorControl(this);
    }

    private getAsyncMapKey(sourceId: number, deviceId: number, commandId: number): string {
        return `${sourceId}, ${ByteConversionUtilities.convertNumberToHexString(deviceId)}, ${ByteConversionUtilities.convertNumberToHexString(commandId)}`;
    }

    /**
     * Retrieve LedControl object
     * @returns LedControl object with which to interact with RVR
     */
    public getLedControl(): LedControl {
        return this._ledControl;
    }

    /**
     * Retrieve DriveControl object
     * @returns DriveControl object with which to interact with RVR
     */
    public getDriveControl(): DriveControl {
        return this._driveControl;
    }

    /**
     * Retrieve InfraredControl object
     * @returns InfraredControl object with which to interact with RVR
     */
    public getInfraredControl(): InfraredControl {
        return this._infraredControl;
    }

    /**
     * Retrieve SensorControl object
     * @returns SensorControl object with which to interact with RVR
     */
    public getSensorControl(): SensorControl {
        return this._sensorControl;
    }

    /**
     * Echo back the payload data (zero data is equivalent to a ping).
     * @param data - Payload data to be echoed as an integer between 0 and 255.
     * @param targetId - Processor target Id to send command to.
     * @returns Promise that resolves with the response from RVR for given command
     */
    public echo(data: Array<number>, targetId: number): Promise<string | never> {
        let url = `${this._baseUrl}/apiAndShell/echo/${targetId}`;

        let jsonBody =  {
            'data': data,
            'isResponseRequested': false
        };
        return fetch(url,  {
            method: 'PUT',
            headers:  {
                'accept': 'application/json',
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(jsonBody)
        }).then(response => {
            return response.text()
        }).then(text => {
            return text;
        });
    }

    /**
     * Gets the version of the main application.
     * @param targetId - Processor target Id to send command to.
     * @returns Promise that resolves with the response from RVR for given command
     */
    public getMainApplicationVersion(targetId: number): Promise<string | never> {
        let url = `${this._baseUrl}/systemInfo/getMainApplicationVersion/${targetId}`;

        return fetch(url,  {
            method: 'GET',
            headers:  {
                'accept': 'application/json',
            }
        }).then(response => {
            return response.text()
        }).then(text => {
            return text;
        });
    }

    /**
     * Gets the version of the bootloader.
     * @param targetId - Processor target Id to send command to.
     * @returns Promise that resolves with the response from RVR for given command
     */
    public getBootloaderVersion(targetId: number): Promise<string | never> {
        let url = `${this._baseUrl}/systemInfo/getBootloaderVersion/${targetId}`;

        return fetch(url,  {
            method: 'GET',
            headers:  {
                'accept': 'application/json',
            }
        }).then(response => {
            return response.text()
        }).then(text => {
            return text;
        });
    }

    /**
     * Gets the board revision number.
     * @returns Promise that resolves with the response from RVR for given command
     */
    public getBoardRevision(): Promise<string | never> {
        let url = `${this._baseUrl}/systemInfo/getBoardRevision/1`;

        return fetch(url,  {
            method: 'GET',
            headers:  {
                'accept': 'application/json',
            }
        }).then(response => {
            return response.text()
        }).then(text => {
            return text;
        });
    }

    /**
     * Gets the robot's MAC address.
     * @returns Promise that resolves with the response from RVR for given command
     */
    public getMacAddress(): Promise<string | never> {
        let url = `${this._baseUrl}/systemInfo/getMacAddress/1`;

        return fetch(url,  {
            method: 'GET',
            headers:  {
                'accept': 'application/json',
            }
        }).then(response => {
            return response.text()
        }).then(text => {
            return text;
        });
    }

    /**
     * Gets the id number assigned by the company for activation tracking.
     * @returns Promise that resolves with the response from RVR for given command
     */
    public getStatsId(): Promise<string | never> {
        let url = `${this._baseUrl}/systemInfo/getStatsId/1`;

        return fetch(url,  {
            method: 'GET',
            headers:  {
                'accept': 'application/json',
            }
        }).then(response => {
            return response.text()
        }).then(text => {
            return text;
        });
    }

    /**
     * Returns the processor name string (as specified to the System Info module). If no name is specified, returns an empty string or no string.
     * @param targetId - Processor target Id to send command to.
     * @returns Promise that resolves with the response from RVR for given command
     */
    public getProcessorName(targetId: number): Promise<string | never> {
        let url = `${this._baseUrl}/systemInfo/getProcessorName/${targetId}`;

        return fetch(url,  {
            method: 'GET',
            headers:  {
                'accept': 'application/json',
            }
        }).then(response => {
            return response.text()
        }).then(text => {
            return text;
        });
    }

    /**
     * Returns the SKU of the bot.
     * @returns Promise that resolves with the response from RVR for given command
     */
    public getSku(): Promise<string | never> {
        let url = `${this._baseUrl}/systemInfo/getSku/1`;

        return fetch(url,  {
            method: 'GET',
            headers:  {
                'accept': 'application/json',
            }
        }).then(response => {
            return response.text()
        }).then(text => {
            return text;
        });
    }

    /**
     * Returns the time (in milliseconds) that has passed since the latest power cycle started.
     * @returns Promise that resolves with the response from RVR for given command
     */
    public getCoreUpTimeInMilliseconds(): Promise<string | never> {
        let url = `${this._baseUrl}/systemInfo/getCoreUpTimeInMilliseconds/1`;

        return fetch(url,  {
            method: 'GET',
            headers:  {
                'accept': 'application/json',
            }
        }).then(response => {
            return response.text()
        }).then(text => {
            return text;
        });
    }

    /**
     * Put robot into a soft sleep state. Driving, LEDS, and sensors are disabled.
     */
    public sleep(): void {
        let url = `${this._baseUrl}/power/sleep/1`;

        fetch(url,  {
            method: 'PUT',
            headers:  {
                'accept': 'application/json',
            }
        });
    }

    /**
     * Wake up the system from soft sleep. Nothing to do if awake.
     */
    public wake(): void {
        let url = `${this._baseUrl}/power/wake/1`;

        fetch(url,  {
            method: 'PUT',
            headers:  {
                'accept': 'application/json',
            }
        });
    }

    /**
     * Get usable battery percentage remaining.
     * @returns Promise that resolves with the response from RVR for given command
     */
    public getBatteryPercentage(): Promise<string | never> {
        let url = `${this._baseUrl}/power/getBatteryPercentage/1`;

        return fetch(url,  {
            method: 'GET',
            headers:  {
                'accept': 'application/json',
            }
        }).then(response => {
            return response.text()
        }).then(text => {
            return text;
        });
    }

    /**
     * Returns the current battery state
     * @returns Promise that resolves with the response from RVR for given command
     */
    public getBatteryVoltageState(): Promise<string | never> {
        let url = `${this._baseUrl}/power/getBatteryVoltageState/1`;

        return fetch(url,  {
            method: 'GET',
            headers:  {
                'accept': 'application/json',
            }
        }).then(response => {
            return response.text()
        }).then(text => {
            return text;
        });
    }

    /**
     * Notification triggered 10 seconds before soft/deep sleep.
     * @param handler - Function called upon receiving corresponding async command; takes form handler()
     */
    public onWillSleepNotify(handler: IAsyncDataHandler): void {
        this.asyncHandlerByName.set('1, 0x13, 0x19', handler);
    }

    /**
     * Notification triggered when robot has entered soft/deep sleep.
     * @param handler - Function called upon receiving corresponding async command; takes form handler()
     */
    public onDidSleepNotify(handler: IAsyncDataHandler): void {
        this.asyncHandlerByName.set('1, 0x13, 0x1A', handler);
    }

    /**
     * Enables or disables notifications for changes to battery voltage state.
     */
    public enableBatteryVoltageStateChangeNotify(isEnabled: boolean): void {
        let url = `${this._baseUrl}/power/enableBatteryVoltageStateChangeNotify/1`;

        let jsonBody =  {
            'isEnabled': isEnabled,
            'isResponseRequested': false
        };
        fetch(url,  {
            method: 'PUT',
            headers:  {
                'accept': 'application/json',
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(jsonBody)
        });
    }

    /**
     * Notification for battery voltage state change.
     * @param handler - Function called upon receiving corresponding async command; takes form handler(data)
     */
    public onBatteryVoltageStateChangeNotify(handler: IAsyncDataHandler): void {
        this.asyncHandlerByName.set('1, 0x13, 0x1C', handler);
    }

    /**
     * Returns the most recent battery voltage reading in volts. This results in a 'Command Failed' API error if the platform does not support calibration. Note that this command does not get a new voltage reading; it returns the most recently read value, which is updated once per second on most robots. To force the battery system to read a new value, use the 'Force Battery Refresh' command.
     * @returns Promise that resolves with the response from RVR for given command
     */
    public getBatteryVoltageInVolts(readingType: number): Promise<string | never> {
        let url = `${this._baseUrl}/power/getBatteryVoltageInVolts/1`;

        let jsonBody =  {
            'readingType': readingType,
            'isResponseRequested': false
        };
        return fetch(url,  {
            method: 'PUT',
            headers:  {
                'accept': 'application/json',
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(jsonBody)
        }).then(response => {
            return response.text()
        }).then(text => {
            return text;
        });
    }

    /**
     * Returns the battery voltage state thresholds and hysteresis value. The hysteresis value is added to the thresholds for rising voltages -- e.g., the voltage must be less than the low threshold to change the state to 'low battery' but it must be greater than (low threshold + hysteresis) to go back to the 'ok battery' state.
     * @returns Promise that resolves with the response from RVR for given command
     */
    public getBatteryVoltageStateThresholds(): Promise<string | never> {
        let url = `${this._baseUrl}/power/getBatteryVoltageStateThresholds/1`;

        return fetch(url,  {
            method: 'GET',
            headers:  {
                'accept': 'application/json',
            }
        }).then(response => {
            return response.text()
        }).then(text => {
            return text;
        });
    }

    /**
     * Get the current draw, in AMPS, from a current sense amplifier
     * @returns Promise that resolves with the response from RVR for given command
     */
    public getCurrentSenseAmplifierCurrent(amplifierId: number): Promise<string | never> {
        let url = `${this._baseUrl}/power/getCurrentSenseAmplifierCurrent/1`;

        let jsonBody =  {
            'amplifierId': amplifierId,
            'isResponseRequested': false
        };
        return fetch(url,  {
            method: 'PUT',
            headers:  {
                'accept': 'application/json',
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(jsonBody)
        }).then(response => {
            return response.text()
        }).then(text => {
            return text;
        });
    }

    /**
     * Run left and right motors at a speed between 0 and 255. Set driving mode using flags.
     */
    public rawMotors(leftMode: number, leftSpeed: number, rightMode: number, rightSpeed: number): void {
        let url = `${this._baseUrl}/drive/rawMotors/2`;

        let jsonBody =  {
            'leftMode': leftMode,
            'leftSpeed': leftSpeed,
            'rightMode': rightMode,
            'rightSpeed': rightSpeed,
            'isResponseRequested': false
        };
        fetch(url,  {
            method: 'PUT',
            headers:  {
                'accept': 'application/json',
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(jsonBody)
        });
    }

    /**
     * Sets current yaw angle to zero. (ie current direction is now considered 'forward'.)
     */
    public resetYaw(): void {
        let url = `${this._baseUrl}/drive/resetYaw/2`;

        fetch(url,  {
            method: 'PUT',
            headers:  {
                'accept': 'application/json',
            }
        });
    }

    /**
     * Drive towards a heading at a particular speed. Flags can be set to modify driving mode.
     */
    public driveWithHeading(speed: number, heading: number, flags: number): void {
        let url = `${this._baseUrl}/drive/driveWithHeading/2`;

        let jsonBody =  {
            'speed': speed,
            'heading': heading,
            'flags': flags,
            'isResponseRequested': false
        };
        fetch(url,  {
            method: 'PUT',
            headers:  {
                'accept': 'application/json',
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(jsonBody)
        });
    }

    /**
     * Enables motor stall notifications.
     */
    public enableMotorStallNotify(isEnabled: boolean): void {
        let url = `${this._baseUrl}/drive/enableMotorStallNotify/2`;

        let jsonBody =  {
            'isEnabled': isEnabled,
            'isResponseRequested': false
        };
        fetch(url,  {
            method: 'PUT',
            headers:  {
                'accept': 'application/json',
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(jsonBody)
        });
    }

    /**
     * Motor stall protection change notification.
     * @param handler - Function called upon receiving corresponding async command; takes form handler(data)
     */
    public onMotorStallNotify(handler: IAsyncDataHandler): void {
        this.asyncHandlerByName.set('2, 0x16, 0x26', handler);
    }

    /**
     * Enables notification for when there is a motor fault.
     */
    public enableMotorFaultNotify(isEnabled: boolean): void {
        let url = `${this._baseUrl}/drive/enableMotorFaultNotify/2`;

        let jsonBody =  {
            'isEnabled': isEnabled,
            'isResponseRequested': false
        };
        fetch(url,  {
            method: 'PUT',
            headers:  {
                'accept': 'application/json',
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(jsonBody)
        });
    }

    /**
     * Notification that a motor fault has occurred.
     * @param handler - Function called upon receiving corresponding async command; takes form handler(data)
     */
    public onMotorFaultNotify(handler: IAsyncDataHandler): void {
        this.asyncHandlerByName.set('2, 0x16, 0x28', handler);
    }

    /**
     * Get the motor fault state.
     * @returns Promise that resolves with the response from RVR for given command
     */
    public getMotorFaultState(): Promise<string | never> {
        let url = `${this._baseUrl}/drive/getMotorFaultState/2`;

        return fetch(url,  {
            method: 'GET',
            headers:  {
                'accept': 'application/json',
            }
        }).then(response => {
            return response.text()
        }).then(text => {
            return text;
        });
    }

    /**
     * Enables the Async messages for when the Gyro max is hit.
     */
    public enableGyroMaxNotify(isEnabled: boolean): void {
        let url = `${this._baseUrl}/sensor/enableGyroMaxNotify/2`;

        let jsonBody =  {
            'isEnabled': isEnabled,
            'isResponseRequested': false
        };
        fetch(url,  {
            method: 'PUT',
            headers:  {
                'accept': 'application/json',
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(jsonBody)
        });
    }

    /**
     * Occurs when the robot spins faster than the sensor can see in any axis.
     * @param handler - Function called upon receiving corresponding async command; takes form handler(data)
     */
    public onGyroMaxNotify(handler: IAsyncDataHandler): void {
        this.asyncHandlerByName.set('2, 0x18, 0x10', handler);
    }

    /**
     * Resets the locator module's current X and Y values to 0.
     */
    public resetLocatorXAndY(): void {
        let url = `${this._baseUrl}/sensor/resetLocatorXAndY/2`;

        fetch(url,  {
            method: 'PUT',
            headers:  {
                'accept': 'application/json',
            }
        });
    }

    /**
     * Sets flags for the locator module.
     */
    public setLocatorFlags(flags: number): void {
        let url = `${this._baseUrl}/sensor/setLocatorFlags/2`;

        let jsonBody =  {
            'flags': flags,
            'isResponseRequested': false
        };
        fetch(url,  {
            method: 'PUT',
            headers:  {
                'accept': 'application/json',
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(jsonBody)
        });
    }

    /**
     * An 8-bit value is returned for each infrared sensor, assigned by mask.
     Mask description on BOLT: 32'h0000_00ff: front left sensor 32'h0000_ff00: front right sensor 32'h00ff_0000: back right sensor 32'hff00_0000: back left sensor
     * @returns Promise that resolves with the response from RVR for given command
     */
    public getBotToBotInfraredReadings(): Promise<string | never> {
        let url = `${this._baseUrl}/sensor/getBotToBotInfraredReadings/2`;

        return fetch(url,  {
            method: 'GET',
            headers:  {
                'accept': 'application/json',
            }
        }).then(response => {
            return response.text()
        }).then(text => {
            return text;
        });
    }

    /**
     * Return raw data being read by RGBC sensor on each sensor channel
     * @returns Promise that resolves with the response from RVR for given command
     */
    public getRgbcSensorValues(): Promise<string | never> {
        let url = `${this._baseUrl}/sensor/getRgbcSensorValues/1`;

        return fetch(url,  {
            method: 'GET',
            headers:  {
                'accept': 'application/json',
            }
        }).then(response => {
            return response.text()
        }).then(text => {
            return text;
        });
    }

    /**
     * For robot following, broadcasting robots emit two codes: one for long distance (3 meters +), and one for short distance (< 1 meter). Following robots use both of these codes to determine direction and distance from the broadcasting robot.
     */
    public startRobotToRobotInfraredBroadcasting(farCode: number, nearCode: number): void {
        let url = `${this._baseUrl}/sensor/startRobotToRobotInfraredBroadcasting/2`;

        let jsonBody =  {
            'farCode': farCode,
            'nearCode': nearCode,
            'isResponseRequested': false
        };
        fetch(url,  {
            method: 'PUT',
            headers:  {
                'accept': 'application/json',
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(jsonBody)
        });
    }

    /**
     * Registers a far code and near code for a following robot to follow. Following robots use the far code and near code emitted by a broadcaster bot to determine direction and distance to travel.
     */
    public startRobotToRobotInfraredFollowing(farCode: number, nearCode: number): void {
        let url = `${this._baseUrl}/sensor/startRobotToRobotInfraredFollowing/2`;

        let jsonBody =  {
            'farCode': farCode,
            'nearCode': nearCode,
            'isResponseRequested': false
        };
        fetch(url,  {
            method: 'PUT',
            headers:  {
                'accept': 'application/json',
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(jsonBody)
        });
    }

    /**
     * Halts current broadcasting or following. De-registers far code and near code on broadcasting or following robot.
     */
    public stopRobotToRobotInfraredBroadcasting(): void {
        let url = `${this._baseUrl}/sensor/stopRobotToRobotInfraredBroadcasting/2`;

        fetch(url,  {
            method: 'PUT',
            headers:  {
                'accept': 'application/json',
            }
        });
    }

    /**
     * Async sent when a registered robot to robot infrared message is received. In response returns the infrared code listened for.
     * @param handler - Function called upon receiving corresponding async command; takes form handler(data)
     */
    public onRobotToRobotInfraredMessageReceivedNotify(handler: IAsyncDataHandler): void {
        this.asyncHandlerByName.set('2, 0x18, 0x2C', handler);
    }

    /**
     * Ambient light value is returned; higher = more light!
     * @returns Promise that resolves with the response from RVR for given command
     */
    public getAmbientLightSensorValue(): Promise<string | never> {
        let url = `${this._baseUrl}/sensor/getAmbientLightSensorValue/1`;

        return fetch(url,  {
            method: 'GET',
            headers:  {
                'accept': 'application/json',
            }
        }).then(response => {
            return response.text()
        }).then(text => {
            return text;
        });
    }

    /**
     * Halts current following. De-registers far code and near code on following robot.
     */
    public stopRobotToRobotInfraredFollowing(): void {
        let url = `${this._baseUrl}/sensor/stopRobotToRobotInfraredFollowing/2`;

        fetch(url,  {
            method: 'PUT',
            headers:  {
                'accept': 'application/json',
            }
        });
    }

    /**
     * Registers a far code and near code for a evading robot to evade. Evading robots use the far code and near code emitted by a broadcaster bot to determine direction and distance to travel.
     */
    public startRobotToRobotInfraredEvading(farCode: number, nearCode: number): void {
        let url = `${this._baseUrl}/sensor/startRobotToRobotInfraredEvading/2`;

        let jsonBody =  {
            'farCode': farCode,
            'nearCode': nearCode,
            'isResponseRequested': false
        };
        fetch(url,  {
            method: 'PUT',
            headers:  {
                'accept': 'application/json',
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(jsonBody)
        });
    }

    /**
     * Halts current evading. De-registers far code and near code on evading robot.
     */
    public stopRobotToRobotInfraredEvading(): void {
        let url = `${this._baseUrl}/sensor/stopRobotToRobotInfraredEvading/2`;

        fetch(url,  {
            method: 'PUT',
            headers:  {
                'accept': 'application/json',
            }
        });
    }

    /**
     * Enable or disable asynchronous color detection notifications. The user must provide an interval and a confidence threshold
     */
    public enableColorDetectionNotify(isEnabled: boolean, interval: number, minimumConfidenceThreshold: number): void {
        let url = `${this._baseUrl}/sensor/enableColorDetectionNotify/1`;

        let jsonBody =  {
            'isEnabled': isEnabled,
            'interval': interval,
            'minimumConfidenceThreshold': minimumConfidenceThreshold,
            'isResponseRequested': false
        };
        fetch(url,  {
            method: 'PUT',
            headers:  {
                'accept': 'application/json',
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(jsonBody)
        });
    }

    /**
     * Notification sent on the interval set by the user in enable_color_detection_notification with information about the color detected.  The color classification ID 0xFF is a special value indicating that the color could not be identified (e.g., because the reading was too dark).  This is expected behavior when the ring is tapped in the air with the sensor facing out.
     * @param handler - Function called upon receiving corresponding async command; takes form handler(data)
     */
    public onColorDetectionNotify(handler: IAsyncDataHandler): void {
        this.asyncHandlerByName.set('1, 0x18, 0x36', handler);
    }

    /**
     * Note: this does not return anything.  Instead, a color_detection_notify async will be sent after measurement with the answer.
     */
    public getCurrentDetectedColorReading(): void {
        let url = `${this._baseUrl}/sensor/getCurrentDetectedColorReading/1`;

        fetch(url,  {
            method: 'PUT',
            headers:  {
                'accept': 'application/json',
            }
        });
    }

    /**
     * Enables the color detection module.
     */
    public enableColorDetection(isEnabled: boolean): void {
        let url = `${this._baseUrl}/sensor/enableColorDetection/1`;

        let jsonBody =  {
            'isEnabled': isEnabled,
            'isResponseRequested': false
        };
        fetch(url,  {
            method: 'PUT',
            headers:  {
                'accept': 'application/json',
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(jsonBody)
        });
    }

    /**
     * Configure streaming services.
     * @param token
     * @param configuration - Array containing the configuration of the client, like the service ID and size.
     * @param targetId - Processor target Id to send command to.
     */
    public configureStreamingService(token: number, configuration: Array<number>, targetId: number): void {
        let url = `${this._baseUrl}/sensor/configureStreamingService/${targetId}`;

        let jsonBody =  {
            'token': token,
            'configuration': configuration,
            'isResponseRequested': false
        };
        fetch(url,  {
            method: 'PUT',
            headers:  {
                'accept': 'application/json',
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(jsonBody)
        });
    }

    /**
     * Start all streaming services for a client
     * @param period - Interval between sensor streaming packets in milliseconds.
     * @param targetId - Processor target Id to send command to.
     */
    public startStreamingService(period: number, targetId: number): void {
        let url = `${this._baseUrl}/sensor/startStreamingService/${targetId}`;

        let jsonBody =  {
            'period': period,
            'isResponseRequested': false
        };
        fetch(url,  {
            method: 'PUT',
            headers:  {
                'accept': 'application/json',
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(jsonBody)
        });
    }

    /**
     * Stops all streaming services for a client
     * @param targetId - Processor target Id to send command to.
     */
    public stopStreamingService(targetId: number): void {
        let url = `${this._baseUrl}/sensor/stopStreamingService/${targetId}`;

        fetch(url,  {
            method: 'PUT',
            headers:  {
                'accept': 'application/json',
            }
        });
    }

    /**
     * Clears all streaming services for a client
     * @param targetId - Processor target Id to send command to.
     */
    public clearStreamingService(targetId: number): void {
        let url = `${this._baseUrl}/sensor/clearStreamingService/${targetId}`;

        fetch(url,  {
            method: 'PUT',
            headers:  {
                'accept': 'application/json',
            }
        });
    }

    /**
     * Streaming data notification for a client configuration
     * @param handler - Function called upon receiving corresponding async command; takes form handler(data)
     */
    public onStreamingServiceDataNotify(handler: IAsyncDataHandler): void {
        this.asyncHandlerByName.set('1, 0x18, 0x3D', handler);
        this.asyncHandlerByName.set('2, 0x18, 0x3D', handler);
    }

    /**
     * Starts listening for infrared messages sent to the robot and will send an async message when received.
     */
    public enableRobotInfraredMessageNotify(isEnabled: boolean): void {
        let url = `${this._baseUrl}/sensor/enableRobotInfraredMessageNotify/2`;

        let jsonBody =  {
            'isEnabled': isEnabled,
            'isResponseRequested': false
        };
        fetch(url,  {
            method: 'PUT',
            headers:  {
                'accept': 'application/json',
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(jsonBody)
        });
    }

    /**
     * Send specified code to any robot in the vicinity. The on/off for each sensor is controlled individually but there can only be one range for all sensors. Therefore, the acceptable combination of emitters strength would be: 5, 5, 0, 0 or 5, 5, 5, 5 or 0, 0, 0, 5, etc.
     */
    public sendInfraredMessage(infraredCode: number, frontStrength: number, leftStrength: number, rightStrength: number, rearStrength: number): void {
        let url = `${this._baseUrl}/sensor/sendInfraredMessage/2`;

        let jsonBody =  {
            'infraredCode': infraredCode,
            'frontStrength': frontStrength,
            'leftStrength': leftStrength,
            'rightStrength': rightStrength,
            'rearStrength': rearStrength,
            'isResponseRequested': false
        };
        fetch(url,  {
            method: 'PUT',
            headers:  {
                'accept': 'application/json',
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(jsonBody)
        });
    }

    /**
     * Get the motor temperature (calculated from motor current) for given a motor index.
     * @returns Promise that resolves with the response from RVR for given command
     */
    public getMotorTemperature(motorIndex: number): Promise<string | never> {
        let url = `${this._baseUrl}/sensor/getMotorTemperature/2`;

        let jsonBody =  {
            'motorIndex': motorIndex,
            'isResponseRequested': false
        };
        return fetch(url,  {
            method: 'PUT',
            headers:  {
                'accept': 'application/json',
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(jsonBody)
        }).then(response => {
            return response.text()
        }).then(text => {
            return text;
        });
    }

    /**
     * Get motor thermal protection status.
     * @returns Promise that resolves with the response from RVR for given command
     */
    public getMotorThermalProtectionStatus(): Promise<string | never> {
        let url = `${this._baseUrl}/sensor/getMotorThermalProtectionStatus/2`;

        return fetch(url,  {
            method: 'GET',
            headers:  {
                'accept': 'application/json',
            }
        }).then(response => {
            return response.text()
        }).then(text => {
            return text;
        });
    }

    /**
     * Enable motor thermal protection status notifications.
     */
    public enableMotorThermalProtectionStatusNotify(isEnabled: boolean): void {
        let url = `${this._baseUrl}/sensor/enableMotorThermalProtectionStatusNotify/2`;

        let jsonBody =  {
            'isEnabled': isEnabled,
            'isResponseRequested': false
        };
        fetch(url,  {
            method: 'PUT',
            headers:  {
                'accept': 'application/json',
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(jsonBody)
        });
    }

    /**
     * Motor thermal protection status notification.
     * @param handler - Function called upon receiving corresponding async command; takes form handler(data)
     */
    public onMotorThermalProtectionStatusNotify(handler: IAsyncDataHandler): void {
        this.asyncHandlerByName.set('2, 0x18, 0x4D', handler);
    }

    /**
     * Returns null-terminated string with the BLE advertising name (e.g., "BL-ABCD").
     * @returns Promise that resolves with the response from RVR for given command
     */
    public getBluetoothAdvertisingName(): Promise<string | never> {
        let url = `${this._baseUrl}/connection/getBluetoothAdvertisingName/1`;

        return fetch(url,  {
            method: 'GET',
            headers:  {
                'accept': 'application/json',
            }
        }).then(response => {
            return response.text()
        }).then(text => {
            return text;
        });
    }

    /**
     * LED affected mask can affect up to 32 LEDs simultaneously. 0 = not affected. 1 = affected (update this LED). If mask value is set to 1, you must provide a value in the LED data array.
     */
    public setAllLeds(ledGroup: number, ledBrightnessValues: Array<number>): void {
        let url = `${this._baseUrl}/io/setAllLeds/1`;

        let jsonBody =  {
            'ledGroup': ledGroup,
            'ledBrightnessValues': ledBrightnessValues,
            'isResponseRequested': false
        };
        fetch(url,  {
            method: 'PUT',
            headers:  {
                'accept': 'application/json',
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(jsonBody)
        });
    }

    /**
     * The response data will list all assigned color palette slots in the system.
     * @returns Promise that resolves with the response from RVR for given command
     */
    public getActiveColorPalette(): Promise<string | never> {
        let url = `${this._baseUrl}/io/getActiveColorPalette/1`;

        return fetch(url,  {
            method: 'GET',
            headers:  {
                'accept': 'application/json',
            }
        }).then(response => {
            return response.text()
        }).then(text => {
            return text;
        });
    }

    /**
     * Each entry in the array corresponds to one color slot in the system.  Any unmentioned slot indices will be marked unassigned.
     */
    public setActiveColorPalette(rgbIndexBytes: Array<number>): void {
        let url = `${this._baseUrl}/io/setActiveColorPalette/1`;

        let jsonBody =  {
            'rgbIndexBytes': rgbIndexBytes,
            'isResponseRequested': false
        };
        fetch(url,  {
            method: 'PUT',
            headers:  {
                'accept': 'application/json',
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(jsonBody)
        });
    }

    /**
     * The response to this command will provide an array of color palette entries that would match on the provided color with higher confidence than the given threshold.
     * @returns Promise that resolves with the response from RVR for given command
     */
    public getColorIdentificationReport(red: number, green: number, blue: number, confidenceThreshold: number): Promise<string | never> {
        let url = `${this._baseUrl}/io/getColorIdentificationReport/1`;

        let jsonBody =  {
            'red': red,
            'green': green,
            'blue': blue,
            'confidenceThreshold': confidenceThreshold,
            'isResponseRequested': false
        };
        return fetch(url,  {
            method: 'PUT',
            headers:  {
                'accept': 'application/json',
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(jsonBody)
        }).then(response => {
            return response.text()
        }).then(text => {
            return text;
        });
    }

    /**
     * Loads the specified color palette into the active palette.
     */
    public loadColorPalette(paletteIndex: number): void {
        let url = `${this._baseUrl}/io/loadColorPalette/1`;

        let jsonBody =  {
            'paletteIndex': paletteIndex,
            'isResponseRequested': false
        };
        fetch(url,  {
            method: 'PUT',
            headers:  {
                'accept': 'application/json',
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(jsonBody)
        });
    }

    /**
     * Stores the active palette into the palette at palette index (see table above).
     */
    public saveColorPalette(paletteIndex: number): void {
        let url = `${this._baseUrl}/io/saveColorPalette/1`;

        let jsonBody =  {
            'paletteIndex': paletteIndex,
            'isResponseRequested': false
        };
        fetch(url,  {
            method: 'PUT',
            headers:  {
                'accept': 'application/json',
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(jsonBody)
        });
    }

    /**
     * Releases LED requests to show the idle indication.
     */
    public releaseLedRequests(): void {
        let url = `${this._baseUrl}/io/releaseLedRequests/1`;

        fetch(url,  {
            method: 'PUT',
            headers:  {
                'accept': 'application/json',
            }
        });
    }

}

interface IAsyncCommandObject {
    _sourceId: number;
    _data: object;
    _commandId: number,
    _deviceId: number;
    _deviceName: string;
    _commandName: string;
}

export class IoSpecdrumsColorPaletteIndiciesEnum {
    public static readonly default: number = 0;
    public static readonly midi: number = 1;
}


export class DriveRawMotorModesEnum {
    public static readonly off: number = 0;
    public static readonly forward: number = 1;
    public static readonly reverse: number = 2;
}

export class DriveMotorIndexesEnum {
    public static readonly leftMotorIndex: number = 0;
    public static readonly rightMotorIndex: number = 1;
}


export class SensorMotorIndexesEnum {
    public static readonly leftMotorIndex: number = 0;
    public static readonly rightMotorIndex: number = 1;
}

export class SensorThermalProtectionStatusEnum {
    public static readonly ok: number = 0;
    public static readonly warn: number = 1;
    public static readonly critical: number = 2;
}

export class SensorStreamingDataSizesEnum {
    public static readonly eightBit: number = 0x00;
    public static readonly sixteenBit: number = 0x01;
    public static readonly thirtyTwoBit: number = 0x02;
}


export class PowerBatteryVoltageStatesEnum {
    public static readonly unknown: number = 0;
    public static readonly ok: number = 1;
    public static readonly low: number = 2;
    public static readonly critical: number = 3;
}

export class PowerBatteryVoltageReadingTypesEnum {
    public static readonly calibratedAndFiltered: number = 0;
    public static readonly calibratedAndUnfiltered: number = 1;
    public static readonly uncalibratedAndUnfiltered: number = 2;
}

export class PowerAmplifierIdsEnum {
    public static readonly leftMotor: number = 0;
    public static readonly rightMotor: number = 1;
}


export class DriveDriveFlagsBitmask {
    public static readonly none: number = 0;
    public static readonly driveReverse: number = 1;
    public static readonly boost: number = 2;
    public static readonly fastTurn: number = 4;
    public static readonly leftDirection: number = 8;
    public static readonly rightDirection: number = 16;
    public static readonly enableDrift: number = 32;
}


export class SensorGyroMaxFlagsBitmask {
    public static readonly none: number = 0;
    public static readonly maxPlusX: number = 1;
    public static readonly maxMinusX: number = 2;
    public static readonly maxPlusY: number = 4;
    public static readonly maxMinusY: number = 8;
    public static readonly maxPlusZ: number = 16;
    public static readonly maxMinusZ: number = 32;
}

export class SensorLocatorFlagsBitmask {
    public static readonly none: number = 0;
    public static readonly autoCalibrate: number = 1;
}

export class SensorInfraredSensorLocationsBitmask {
    public static readonly none: number = 0;
    public static readonly frontLeft: number = 0x000000FF;
    public static readonly frontRight: number = 0x0000FF00;
    public static readonly backRight: number = 0x00FF0000;
    public static readonly backLeft: number = 0xFF000000;
}


export class SpheroRvrLedBitmasks {
    public static readonly rightHeadlightRed: number = 0x00000001;
    public static readonly rightHeadlightGreen: number = 0x00000002;
    public static readonly rightHeadlightBlue: number = 0x00000004;
    public static readonly leftHeadlightRed: number = 0x00000008;
    public static readonly leftHeadlightGreen: number = 0x00000010;
    public static readonly leftHeadlightBlue: number = 0x00000020;
    public static readonly leftStatusIndicationRed: number = 0x00000040;
    public static readonly leftStatusIndicationGreen: number = 0x00000080;
    public static readonly leftStatusIndicationBlue: number = 0x00000100;
    public static readonly rightStatusIndicationRed: number = 0x00000200;
    public static readonly rightStatusIndicationGreen: number = 0x00000400;
    public static readonly rightStatusIndicationBlue: number = 0x00000800;
    public static readonly batteryDoorRearRed: number = 0x00001000;
    public static readonly batteryDoorRearGreen: number = 0x00002000;
    public static readonly batteryDoorRearBlue: number = 0x00004000;
    public static readonly batteryDoorFrontRed: number = 0x00008000;
    public static readonly batteryDoorFrontGreen: number = 0x00010000;
    public static readonly batteryDoorFrontBlue: number = 0x00020000;
    public static readonly powerButtonFrontRed: number = 0x00040000;
    public static readonly powerButtonFrontGreen: number = 0x00080000;
    public static readonly powerButtonFrontBlue: number = 0x00100000;
    public static readonly powerButtonRearRed: number = 0x00200000;
    public static readonly powerButtonRearGreen: number = 0x00400000;
    public static readonly powerButtonRearBlue: number = 0x00800000;
    public static readonly leftBrakelightRed: number = 0x01000000;
    public static readonly leftBrakelightGreen: number = 0x02000000;
    public static readonly leftBrakelightBlue: number = 0x04000000;
    public static readonly rightBrakelightRed: number = 0x08000000;
    public static readonly rightBrakelightGreen: number = 0x10000000;
    public static readonly rightBrakelightBlue: number = 0x20000000;
    public static readonly undercarriageWhite: number = 0x40000000;
}
export class RvrLedGroups {
    public static readonly rightHeadlight: number = 0x00000007;
    public static readonly leftHeadlight: number = 0x00000038;
    public static readonly leftStatusIndication: number = 0x000001c0;
    public static readonly rightStatusIndication: number = 0x00000e00;
    public static readonly batteryDoorRear: number = 0x00007000;
    public static readonly batteryDoorFront: number = 0x00038000;
    public static readonly powerButtonFront: number = 0x001c0000;
    public static readonly powerButtonRear: number = 0x00e00000;
    public static readonly leftBrakelight: number = 0x07000000;
    public static readonly rightBrakelight: number = 0x38000000;
    public static readonly undercarriage: number = 0x40000000;
    public static readonly allLights: number = 0x3fffffff;
}
